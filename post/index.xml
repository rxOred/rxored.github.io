<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on rxOred&#39;s blog</title>
    <link>https://rxOred.github.io/post/</link>
    <description>Recent content in Posts on rxOred&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 23 Oct 2021 14:20:04 +0000</lastBuildDate><atom:link href="https://rxOred.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bypassing AMSI (Antimalware Scan Interface) With CSharp 0x00</title>
      <link>https://rxOred.github.io/post/csharploader/bypassing-amsi-with-csharp/</link>
      <pubDate>Sat, 23 Oct 2021 14:20:04 +0000</pubDate>
      
      <guid>https://rxOred.github.io/post/csharploader/bypassing-amsi-with-csharp/</guid>
      <description>Ah yes. Windoz, the most popular desktop operating system solution out there. And, the most attacker-friendly operating system out there. At least, was.
Windows has a really good reputation in the malware industry. Red teamers often use this to their advantage and use malware to maintain persistent access to the victim machine.
Out of the tools that they use to fulfill this task, script-based malware and payloads play a major role.</description>
      <content>&lt;p&gt;Ah yes. Windoz, the most popular desktop operating system solution out there. And, the most attacker-friendly operating system out there. At least, &lt;code&gt;was&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Windows has a really good reputation in the malware industry. Red teamers often use this to their advantage and use malware to maintain persistent access to the victim machine.&lt;/p&gt;
&lt;p&gt;Out of the tools that they use to fulfill this task, script-based malware and payloads play a major role. And to execute those stuff, they mostly use Windows PowerShell, a powerful administrative tool mostly used by sysadmins. Another most important software when it comes to windows malware is Microsoft office software. It is a proven fact that the most notable malware outbreaks in the past few years have something to do with VBA macros. in 2007 Microsoft shipped office packages with macro disabled by default. Yet those type of malware is still alive and well.&lt;/p&gt;
&lt;p&gt;And as a result, Microsoft and antimalware vendors have developed many security mechanisms to deal with those threats. For example, modern anti-malware solutions can statically analyze scripts, binaries and detect whether they are malicious or not using signatures such as strings.&lt;/p&gt;
&lt;p&gt;And because of that, malware authors use various techniques to bypass those defense mechanisms. One of the major techniques is code obfuscation.&lt;/p&gt;
&lt;p&gt;consider the following example, that I took from MSDN.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; displayEvilString
    &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        Write-Host &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;pwnd!&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Assuming the above PowerShell snippet is malicious, we can write a signature to detect the malware. this signature can be &lt;code&gt;Write-Host &#39;pwnd!&#39;&lt;/code&gt; or simply &lt;code&gt;&#39;pwnd!&#39;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So to avoid signature-based detection, the above snippet can be obfuscated like shown below.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; obfuscatedDisplayEvilString
    &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        $xorKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;
        $code &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LHsJexJ7D3see1Z7M3sUewh7D3tbe1x7C3sMexV7H3tae1x7&amp;#34;&lt;/span&gt;
        $byte &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;Convert&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;::FromBase64String&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;$code&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
        $newBytes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; foreach&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;$byte in $bytes&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            $byte -bxor $xorKey
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        $newCode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;System.Text.Encoding&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;::Unicode.GetString&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;$newBytes&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And this is a win for malware authors since this is beyond what anti-malware solutions can emulate or detect until AMSI joins the conversation.&lt;/p&gt;
&lt;h2 id=&#34;antimalware-scan-interface-amsi&#34;&gt;Antimalware Scan Interface (AMSI)&lt;/h2&gt;
&lt;p&gt;AMSI is a standard interface that allows applications to interact with anti-malware products installed on the system. This means is that it provides
an API for Application developers. Application developers can use the API to implement security features to make sure that the end-user is safe. According
to Microsoft, that&amp;rsquo;s why they consider Application developers as a target audience of this standard interface.&lt;/p&gt;
&lt;p&gt;The other one is Anti-malware vendors. Any anti-malware vendor can provide an interface for AMSI to work with. By doing that, they can detect a large number of malicious activities that they could not.  By default, AMSI uses Windows defender as the backing detection engine.&lt;/p&gt;
&lt;p&gt;According to Microsoft, AMSI provides the following features by default.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;User Account Control&lt;/li&gt;
&lt;li&gt;PowerShell&lt;/li&gt;
&lt;li&gt;Windows Script Host&lt;/li&gt;
&lt;li&gt;JScript &amp;amp;&amp;amp; VBScript&lt;/li&gt;
&lt;li&gt;Office VBA macros&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As it is clear from those default features, AMSI specifically provides anti-malware security mechanisms to defend against dynamic script-based malware.&lt;/p&gt;
&lt;p&gt;when running a script, even though the code is initially obfuscated, it has to be deobfuscated to go through the scripting engine. At this point, AMSI APIs can be used to scan the script and determine whether it is malicious or not.&lt;/p&gt;
&lt;p&gt;AMSI can also be useful in scenarios like invoking malicious PowerShell commands.&lt;/p&gt;
&lt;p&gt;In this article I&amp;rsquo;m going to focus on the internals of AMSI. in the next one, I&amp;rsquo;ll provide y&amp;rsquo;all with some bypass techniques.&lt;/p&gt;
&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;
&lt;p&gt;So let&amp;rsquo;s take SafeSploit as our example.&lt;/p&gt;
&lt;p&gt;When we run the binary, the result we get is.
&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/AMSI.png&#34; alt=&#34;AMSI&#34;&gt;&lt;/p&gt;
&lt;p&gt;See, as we expected, PowerShell stops the execution of the program once it has detected the program is suspicious using AMSI.
So, how can we bypass this?, well before that, we have to dive deep into AMSI internals to understand how things work.&lt;/p&gt;
&lt;h2 id=&#34;amsi-internals&#34;&gt;AMSI internals&lt;/h2&gt;
&lt;p&gt;As I previously mentioned, any anti-malware vendor can become an AMSI provider and inspect data sent by applications via the AMSI interface. If the content submitted for the scan is detected as malicious, the consuming application will be alerted. In our case, Windows PowerShell uses Windows defender as the AMSI provider.
When we input a malicious command or execute a malicious program, PowerShell will pass everything to windows defender before doing any execution.
Anti-malware vendors must do all the scans and detect whether the received input is malicious or not.&lt;/p&gt;
&lt;p&gt;For application programmers to interact with the AMSI, it provides a dll called, amsi.dll. Let&amp;rsquo;s examine PowerShell from a process hacker to check whether this dll is loaded.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/powershellProperties.png&#34; alt=&#34;PoweshellProperties&#34;&gt;&lt;/p&gt;
&lt;p&gt;as we can see, amsi.dll has been loaded into powershell.exe. Now, let&amp;rsquo;s take a look at this dll in-depth and see if we can find anything interesting.
Even without looking at the dll, we can think of a technique to bypass AMSI, using dll injection and impersonating several functions exported by the dll. Anyway, let&amp;rsquo;s choose the hard way, and before diving deep into disassembly, let&amp;rsquo;s examine the export table of amsi.dll.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/Exports.png&#34; alt=&#34;Exports&#34;&gt;&lt;/p&gt;
&lt;p&gt;Out of the above exported functions, only two are important to us.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AmsiScanBuffer&lt;/li&gt;
&lt;li&gt;AmsiScanString&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;amsiscanbuffer&#34;&gt;AmsiScanBuffer&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiscanbuffer&#34;&gt;here&lt;/a&gt;, check out the documentation first. According to the MSDN and as well as the name suggests, the &lt;code&gt;AmsiScanBuffer&lt;/code&gt; function scans a buffer that is filled for malware.&lt;/p&gt;
&lt;p&gt;As MSDN says, this function returns &lt;code&gt;S_OK&lt;/code&gt; if the call is successful. However, the return value does not indicate whether the buffer is malicious. instead, the function uses an output parameter of type &lt;code&gt;AMSI_RESULT&lt;/code&gt; to send the scan results.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; AMSI_RESULT {
        AMSI_RESULT_CLEAN,
        AMSI_RESULT_NOT_DETECTED,
        AMSI_RESULT_BLOCKED_BY_ADMIN_START,
        AMSI_RESULT_BLOCKED_BY_ADMIN_END,
        AMSI_RESULT_DETECTED
    } ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And here&amp;rsquo;s how this function looks like in disassembly.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/AmsiScanBufferPrologue.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;here we can see stack pointer is stored in &lt;code&gt;r11&lt;/code&gt; register and since this is x64 _stdcall, the first four parameters are stored in rcx, rdx, r8 and r9 registers. Rest are stored in the stack. With that information, we can assume a pointer to the &lt;code&gt;AMSI_RESULT&lt;/code&gt; enum is stored in the stack.&lt;/p&gt;
&lt;p&gt;then we can see a series of comparisons around global data.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/AmsiScanBuffer2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;followed by,&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/AmsiScanBuffer4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;which can be decompiled down into,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;    HRESULT &lt;span style=&#34;color:#66d9ef&#34;&gt;__stdcall&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AmsiScanBuffer&lt;/span&gt;
    (
            HAMSICONTEXT amsiContext, 
            PVOID buffer, 
            ULONG length, 
            LPCWSTR contentName, 
            HAMSISESSION amsiSession, 
            AMSI_RESULT &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;result
    )
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; var;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((handle &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;handle) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(handle &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1c&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;))
        {
            SomeFunc(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(handle &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;), buffer, lengthm amsiSession, result);
        }

        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (buffer &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; amsiContext &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; 
            (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;amsiContext) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x49534D41&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(amsiContext &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(amsiContext &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt;) 
        {
            var &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x80070057&lt;/span&gt;;    
        } 
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; 
        {
            &lt;span style=&#34;color:#75715e&#34;&gt;/* ################################ */&lt;/span&gt;
            var &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(amsiContext &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x4&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x18&lt;/span&gt;)();
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So the function takes 6 parameters. One of which is the pointer to the &lt;code&gt;AMSI_RESULT&lt;/code&gt; structure as I explained above - &lt;code&gt;*result&lt;/code&gt;. According to MSDN, others include a buffer, which will be 
scanned by the anti-malware vendor - &lt;code&gt;buffer&lt;/code&gt;, length of the buffer - &lt;code&gt;length&lt;/code&gt;, filename, URL, unique script ID - &lt;code&gt;contentName&lt;/code&gt; and a handler to the session - &lt;code&gt;HAMSISESSION&lt;/code&gt; structure.&lt;/p&gt;
&lt;p&gt;then the function does some checks against the handle, if the checks turn out to be false, it calls a random function which I haven&amp;rsquo;t analyzed, and continues the execution from the next if condition. else, it continues execution without ever calling that random function. (i named that &amp;lsquo;random function&amp;rsquo; &lt;code&gt;SomeFunc&lt;/code&gt; :3 ).&lt;/p&gt;
&lt;p&gt;then there is a pretty huge if condition, which I&amp;rsquo;m not gonna go through (read the decompiled version and understand it :3 ). And if the condition fails, we call another random function but this time, it&amp;rsquo;s not a random function. it is a function pointer that is extracted from the &lt;code&gt;amsiContext&lt;/code&gt; parameter. And I&amp;rsquo;m pretty much sure that this function pointer is some kind of a handler to the anti-malware vendor&amp;rsquo;s scanning interface.&lt;/p&gt;
&lt;p&gt;This makes sense because to call &lt;code&gt;AmsiScanBuffer&lt;/code&gt;, one has to initialize amsi with &lt;code&gt;AmsiInitialize&lt;/code&gt; and open a session if required with &lt;code&gt;AmsiOpenSession&lt;/code&gt;. And &lt;code&gt;AmsiInitialize&lt;/code&gt; returns a handler and that handler is then passed down to this function as the first parameter (amsiContext).&lt;/p&gt;
&lt;p&gt;So the conclusion is, when &lt;code&gt;AmsiInitialize&lt;/code&gt; function gets called, it initializes the anti-malware vendor, registers it, and returns a handler that contains a pointer to a registered function.&lt;code&gt;AmsiScanBuffer&lt;/code&gt; function is responsible for doing some basic checks on the handler, extracting registered function from the handler and calling it with necessary parameters.&lt;/p&gt;
&lt;h2 id=&#34;amsiscanstring&#34;&gt;AmsiScanString&lt;/h2&gt;
&lt;p&gt;this is pretty much the same as the previous function except this one scan for strings. let&amp;rsquo;s just do a small analysis on this one too for the sake of completeness.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/AmsiScanString.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Function check if the string is empty or not.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/CSharpLoader/AmsiScanString1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;here is how the rest of the function looks like.&lt;/p&gt;
&lt;p&gt;Without much analysis, we can clearly say that this one calls &lt;code&gt;AmsiScanString&lt;/code&gt; internally. before that, it checks whether the enum pointed by &lt;code&gt;target&lt;/code&gt; is empty.&lt;/p&gt;
&lt;p&gt;Then there is a loop that increases &lt;code&gt;rax&lt;/code&gt; register until it finds a null byte. This is a strlen. After that, &lt;code&gt;rax&lt;/code&gt; is added to &lt;code&gt;rax&lt;/code&gt; and gets compared to &lt;code&gt;r11&lt;/code&gt;, which holds value &lt;code&gt;0xFFFFFFFF&lt;/code&gt;, if the value in &lt;code&gt;rax&lt;/code&gt; is above &lt;code&gt;0xFFFFFFFF&lt;/code&gt;, it moves &lt;code&gt;0x80070057&lt;/code&gt; to &lt;code&gt;rax&lt;/code&gt; register and returns. else, it calls &lt;code&gt;AmsiScanBuffer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And what this function does is pretty simple. it checks if the string length is higher than some value and if yes, it returns after some random value loaded into rax, and else, it simply calls &lt;code&gt;AmsiScanBuffer&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;thats-it-kids&#34;&gt;that&amp;rsquo;s it, kids!&lt;/h2&gt;
&lt;p&gt;So yeah that&amp;rsquo;s it for now&amp;hellip; we explored AMSI in-depth in this article. In the next one, We will go through some common AMSI bypass techniques.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Practical Reverse Engineering Answers 2 - sample_J DllMain</title>
      <link>https://rxOred.github.io/post/practical-re/practical-re-answers2/</link>
      <pubDate>Sat, 02 Oct 2021 00:40:06 +0000</pubDate>
      
      <guid>https://rxOred.github.io/post/practical-re/practical-re-answers2/</guid>
      <description>So last time we finished some exercises from the book pratical reverse engineering. Now, we have page 35 exercises. I wont cover exercise here because some are really straight forward.
without useless intros lets get started.
Chaper 1, page 35 We are starting with the second one, because first one is pretty easy. 2nd question asks us to decompile DllMain.
as we can see, IDA has generated us some information of the stack as well as a nice graph view.</description>
      <content>&lt;p&gt;So last time we finished some exercises from the book pratical reverse engineering. Now, we have page 35 exercises. I wont cover exercise here because some are really straight forward.&lt;/p&gt;
&lt;p&gt;without useless intros lets get started.&lt;/p&gt;
&lt;h1 id=&#34;chaper-1-page-35&#34;&gt;Chaper 1, page 35&lt;/h1&gt;
&lt;p&gt;We are starting with the second one, because first one is pretty easy. 2nd question asks us to decompile DllMain.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/dllmain.png&#34; alt=&#34;dllmain, DllMain&#34;&gt;&lt;/p&gt;
&lt;p&gt;as we can see, IDA has generated us some information of the stack as well as a nice graph view. From that, we can decompile it down to,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;   BOOL &lt;span style=&#34;color:#66d9ef&#34;&gt;__stdcall&lt;/span&gt; APIENTRY &lt;span style=&#34;color:#a6e22e&#34;&gt;DllMain&lt;/span&gt;(HMODULE &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;hModule, 
                           DWORD ul_reason_for_call, 
                           LPVOID lpReserved)
   {
      IDTR idtr;
      PROCESSENTRY32 pe;
      HANDLE handle;
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/sidt.png&#34; alt=&#34;prologue&#34;&gt;&lt;/p&gt;
&lt;p&gt;next we can the function prologue, where stack frame is initialized. using &lt;code&gt;sub esp, 130h&lt;/code&gt; instruction, we can confirm that stack will be 0x130 bytes large. next we can see a &lt;code&gt;sidt fword[ebp+idtr]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;if you have some low level debugging/development experience, you might know what &lt;code&gt;sidt&lt;/code&gt; does. in case you dont, it reads idtr register to the operand location. in this case, &lt;code&gt;fword[ebp+idr]&lt;/code&gt;will be filled with idtr register. So whats this idtr register? well, idtr register is a 6byte sized register. it stores length of the interrupt desciptor table in the last 2 bytes and base of interrupt desciptor table in the top 4 bytes. Now, how can we call &lt;code&gt;sidt&lt;/code&gt; from C/C++?&lt;/p&gt;
&lt;p&gt;before that, here we build the idtr structure&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; idtr {
      DWORD idt_base;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; idt_size;
   } IDTR, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;PIDTR;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;inside DllMain we do this.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;   IDTR idtr;
   __sidt(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;idtr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;then DllMain compares &lt;code&gt;idtr+2&lt;/code&gt; with some 2 random hex values that looks like memory addresses. Using the above explaination, it is pretty clear that whoever wrote this malware compares base address of interrupt desciptor table with 2 hardcoded memory addresses, first as we can see in the above image, 0x8003f400 and 0x80047400 in the below image. Tbh, this is bad. Reason is that, in multi core processors each core gets a different base address for interrupt desciptor table. And when using hardcoded addresses&amp;hellip; Anyway. lets decompile that part too.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/checkidt.png&#34; alt=&#34;idt address range&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (idtr.idt_base &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x8003f400&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; idtr.idt_base &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x80047400&lt;/span&gt;){
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; FALSE;
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;From above snippet it is clear that it does check for some range. looks like it validates IDT base&amp;hellip;&lt;/p&gt;
&lt;p&gt;After the comparision if the range requirements are satisfied, we can see that DllMain creates a snapshot of all the running processes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/snapshot.png&#34; alt=&#34;CreateToolhelp32Snapshot&#34;&gt;&lt;/p&gt;
&lt;p&gt;we can decompile that stub into&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;   handle &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
   &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (handle &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; INVALID_HANDLE_VALUE) {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; FALSE;
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;it also zero out &lt;code&gt;pe&lt;/code&gt; using &lt;code&gt;stosd&lt;/code&gt; instruction.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;   memset(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;pe.cntUsage, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x49&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Next, DllMain calls &lt;code&gt;Process32First&lt;/code&gt; with arguements &lt;code&gt;&amp;amp;pe&lt;/code&gt;(eax) and &lt;code&gt;handle&lt;/code&gt;(edi), a string comparison with &lt;code&gt;explorer.exe&lt;/code&gt; and then if comparison fails, we can see a call to &lt;code&gt;Process32Next&lt;/code&gt;.
Basically this stub go through each process of the snapshot until it finds &lt;code&gt;explorer.exe&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/getexplorer.png&#34; alt=&#34;Process32First&#34;&gt;&lt;/p&gt;
&lt;p&gt;decompiled version of that stub may look like&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;   pe.dwSize &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(PROCESSENTRY32);
   &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (Process32First(handle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;pe) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
      &lt;span style=&#34;color:#75715e&#34;&gt;// code here
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   }
   &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (Process32Next(handle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;pe) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
         &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (wcscmp(pe.szExeFile, &lt;span style=&#34;color:#e6db74&#34;&gt;L&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;explorer.exe&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
            &lt;span style=&#34;color:#75715e&#34;&gt;// code here
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;         }
         &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
      }
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; FALSE;
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once it found the explorer.exe, it compares the process&amp;rsquo;s pid to it&amp;rsquo;s parents pid.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/checkpid.png&#34; alt=&#34;check process ids&#34;&gt;&lt;/p&gt;
&lt;p&gt;here if they are equal, we simply exit out.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/exit.png&#34; alt=&#34;exit&#34;&gt;&lt;/p&gt;
&lt;p&gt;else, we create a thread in the current virtual memory space with start address set to &lt;code&gt;0x100032d0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rxOred.github.io/img/evil.png&#34; alt=&#34;evil stuff&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;   do_evil_stuff:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (pe.th32ParentProcessID &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; pe.th32ProcessID) {
         &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; FALSE;
      }
      &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
         &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (ul_reason_for_call &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; DLL_PROCESS_ACCESS) {
            CreateThread(
               NULL, NULL, (LPTHREAD_START_ROUTINE)&lt;span style=&#34;color:#ae81ff&#34;&gt;0x100032d0&lt;/span&gt;, NULL, NULL, NULL
            );
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; TRUE;
         }
         &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; TRUE:
      }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;with that info, we can fill out the stub that searches for explorer.exe like this&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;   pe.dwSize &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(PROCESSENTRY32);
   &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (Process32First(handle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;pe) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (wcscmp(pe.szExeFile, &lt;span style=&#34;color:#e6db74&#34;&gt;L&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;explorer.exe&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
         &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; do_evil_stuff;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
         &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (Process32Next(handle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;pe) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (wcscmp(pe.szExeFile, &lt;span style=&#34;color:#e6db74&#34;&gt;L&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;explorer.exe&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
               &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; do_evil_stuff;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
         }
         &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; FALSE;
      }
   }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;combining all into a single stub, we will get something like this as the DllMain&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idtr&lt;/span&gt; {
      DWORD idt_base;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; idt_size;
   } IDTR, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;PIDTR;

   BOOL &lt;span style=&#34;color:#66d9ef&#34;&gt;__stdcall&lt;/span&gt; APIENTRY &lt;span style=&#34;color:#a6e22e&#34;&gt;DllMain&lt;/span&gt;(HMODULE &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;hModule, 
                           DWORD ul_reason_for_call, 
                           LPVOID lpReserved)
   {
      IDTR idtr;
      PROCESSENTRY32 pe;
      HANDLE handle;

      __sidt(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;idtr);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (idtr.idt_base &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x80047400&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; idtr.idt_base &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x8003f400&lt;/span&gt;){
         &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; FALSE;
      }

      handle &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (handle &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; INVALID_HANDLE_VALUE) {
         &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; FALSE;
      }
      memset(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;pe.cntUsage, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x49&lt;/span&gt;);
      pe.dwSize &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(PROCESSENTRY32);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (Process32First(handle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;pe) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
         &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (wcscmp(pe.szExeFile, &lt;span style=&#34;color:#e6db74&#34;&gt;L&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;explorer.exe&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; do_evil_stuff;
         &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (Process32Next(handle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;pe) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
               &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (wcscmp(pe.szExeFile, &lt;span style=&#34;color:#e6db74&#34;&gt;L&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;explorer.exe&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
                  &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; do_evil_stuff;
               }
               &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; FALSE;
         }
      }

   do_evil_stuff:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (pe.th32ParentProcessID &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; pe.th32ProcessID) {
         &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; FALSE;
      }
      &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
         &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (ul_reason_for_call &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; DLL_PROCESS_ACCESS) {
            CreateThread(
               NULL, NULL, (LPTHREAD_START_ROUTINE)&lt;span style=&#34;color:#ae81ff&#34;&gt;0x100032d0&lt;/span&gt;, NULL, NULL, NULL
            );
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; TRUE;
         }
         &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; TRUE:
      }
   }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </item>
    
    <item>
      <title>Practical Reverse Engineering Answers</title>
      <link>https://rxOred.github.io/post/practical-re/practical-re-answers/</link>
      <pubDate>Wed, 29 Sep 2021 09:46:25 +0000</pubDate>
      
      <guid>https://rxOred.github.io/post/practical-re/practical-re-answers/</guid>
      <description>Introduction Hello, rxOred here, with another badly written write-up.
A years ago, i started reading practical reverse engineering book. Eventhough I was familiar with most of those concepts, that book&amp;rsquo;s exercises were pretty challenging. Aand guess what, there were no solutions to those Exercises in the book. Authors have encouraged RE community to share solutions with others using their blogs, r/reverse-egnineering etc.
At that time, i never really wanted to create a blog.</description>
      <content>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Hello, rxOred here, with another badly written write-up.&lt;/p&gt;
&lt;p&gt;A years ago, i started reading practical reverse engineering book. Eventhough I was familiar with most of those concepts,
that book&amp;rsquo;s exercises were pretty challenging.
Aand guess what, there were no solutions to those Exercises in the book. Authors have encouraged RE community to share 
solutions with others using their blogs, r/reverse-egnineering etc.&lt;/p&gt;
&lt;p&gt;At that time, i never really wanted to create a blog. however while doing those challenges, i have wrote 
some, not-very-detailed explainations. So, i will be sharing those stuff with yall.
This 2 part series post will provide some solutions for Exercises in chapter 1, which is about x86.&lt;/p&gt;
&lt;h1 id=&#34;chapter-1-page-11&#34;&gt;Chapter 1, page 11&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;4 bytes (32 bits). makes sense right? if you have read the whole snippet, line 5 is a,
repne scasb
intel indentifies these instructions as string operation instructions. which is perfectly fine.About scasb,
scasb/scasw/scasd instructions compare al/ax/eax with value at memory address specified in edi. rep is a prefix. 
it is used for repeating same thing. So the what the whole instruction does is, it compares al (because scas&amp;rsquo;b&#39;) 
with whatever value at memory address specified in edi while increasing edi by 1 until the byte is found in the 
buffer or ecx == 0. so as for our answer, it is 4 bytes because since edi is an memory address, memory addresses in
x86 takes upto 4bytes :)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1 byte
rep stosb
this instruction is used to initialize a buffer with some value (like memset). edi should contain the address of 
buffer, and since its a stos&amp;rsquo;b&#39;, which is the indication of byte, al contain the value that the buffer should be
assigned with. So from that, it is clear that ebp+c, second argument to the function is sizeof byte:)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What the snippet does is pretty simple, in line 1, edi is assigned with ebp+8 (first arg), which we concluded as a
memory address. next line, we can see that its saving that address in edx followed by a xor eax, eax, which clears 
out eax register. In line 4, ecx is ored(did i spell that correct?) with 0xffffffff. result of this operation is, 
well, 0xffffffff because anything | 1 results in a 1.&lt;/p&gt;
&lt;p&gt;then we have what we discussed in 1), repe scasb. I won&amp;rsquo;t explain it again ew.&lt;/p&gt;
&lt;p&gt;So next we have some add ecx, 2, which, as anyone can guess, adds 2 to ecx. Followed by a negation. then we have a
mov  al, ebp+c, which moves our byte into al register. then edi is assigned with edx, where we saved our edi before.
Then we have what we discussed in 2).&lt;/p&gt;
&lt;p&gt;So what this basically does is, it compares 0 with whatever at memory address edi until 0 is found in the 
buffer while decrementing ecx. then we set ecx + 2, then we negate it to get the string len, then we write [ebp-c] 
to [edi] byte by byte :3&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;chapter-1-page-17&#34;&gt;Chapter 1, page 17&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;So, in this exercise we want to write a program that reads instruction pointer :3. here we go&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;; here we are reading address of the instruction after the call instruction.&lt;/span&gt;
   readeip: &lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;     lbl         &lt;span style=&#34;color:#75715e&#34;&gt;; call lbl, this pushes address of next instruction to the stack&lt;/span&gt;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;      ebx, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;      eax, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt;      &lt;span style=&#34;color:#ae81ff&#34;&gt;0x80&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;; exit&lt;/span&gt;

   lbl:     &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;      eax, [esp]  &lt;span style=&#34;color:#75715e&#34;&gt;; we read value at esp to eax. which is the return address.&lt;/span&gt;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Next we have to set eip to 0xAABBCCDD&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;; 1. here we when we call, return address is pushed to stack&lt;/span&gt;
   writeeip:   &lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;  write
               &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;   ebx,  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
               &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;   eax,  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
               &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt;   &lt;span style=&#34;color:#ae81ff&#34;&gt;0x80&lt;/span&gt;

   &lt;span style=&#34;color:#75715e&#34;&gt;; 2. we then modify the value at stack to 0xAABBCCDD&lt;/span&gt;
   write:      &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;   [esp], &lt;span style=&#34;color:#ae81ff&#34;&gt;0xAABBCCDD&lt;/span&gt;
               &lt;span style=&#34;color:#a6e22e&#34;&gt;ret&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;; cause a segfault&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;   writeeip:   &lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;  write

   &lt;span style=&#34;color:#75715e&#34;&gt;; remember, ret just pops whatever at esp to eip&lt;/span&gt;
   write:      &lt;span style=&#34;color:#a6e22e&#34;&gt;push&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0xAABBCCDD&lt;/span&gt;
               &lt;span style=&#34;color:#a6e22e&#34;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;   writeeip: &lt;span style=&#34;color:#a6e22e&#34;&gt;jmp&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0xAABBCCDD&lt;/span&gt;
   &lt;span style=&#34;color:#75715e&#34;&gt;;yeaup simple as that&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;   writeeip: &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     eax, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xAABBCCDD&lt;/span&gt;
             &lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;    eax
   &lt;span style=&#34;color:#75715e&#34;&gt;; this is bit important. lot of malware authors use this method to access win32 APIs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;same thing that happened to many of above snippets ?. it will crash with a seg fault. The reason is that, we are returning to 
a totally unknown address.
In this case we havent pushed anything to the stack other than return address and base pointer of the prev stack frame. and when ret pops the value from stack to eip, and what we get is base of the previous
stack frame. Guess what? stack is non-executable :3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  --------------------------
           eax (y)
  --------------------------
           ecx (x)
  --------------------------
        (return addr)
  --------------------------
             ebp             &amp;lt;------- esp
  --------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;edx:eax will be used.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;the-end&#34;&gt;THE-END&lt;/h1&gt;
&lt;p&gt;In the next article, we will go through the last exercise :) Until then!&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Compilers 101 - The front end</title>
      <link>https://rxOred.github.io/post/compilers/compilers01/</link>
      <pubDate>Tue, 28 Sep 2021 22:58:02 +0000</pubDate>
      
      <guid>https://rxOred.github.io/post/compilers/compilers01/</guid>
      <description>Compilers This article is all about compilers.
For many people, a compiler is a mystery. for them, it is like a magical black box that takes the source file as an input and generates a binary file that can be executed.
However, the truth to be told, compilers are not wizards. In this article, we will start from the introduction to the front-end of a compiler from a reverse-engineering perspective.</description>
      <content>&lt;h1 id=&#34;compilers&#34;&gt;Compilers&lt;/h1&gt;
&lt;p&gt;This article is all about compilers.&lt;/p&gt;
&lt;p&gt;For many people, a compiler is a mystery. for them, it is like a magical black box that takes the source file as an input and generates a binary file that can be executed.&lt;/p&gt;
&lt;p&gt;However, the truth to be told, compilers are not wizards. In this article, we will start from the introduction to the front-end of a compiler from a reverse-engineering perspective.&lt;/p&gt;
&lt;p&gt;The next articles will contain detailed explanations of the optimizer and the back-end.&lt;/p&gt;
&lt;h2 id=&#34;what-is-a-compiler-and-how-does-it-affect-the-reverse-engineering-process&#34;&gt;What is a compiler and how does it affect the reverse engineering process.&lt;/h2&gt;
&lt;p&gt;A compiler is a very complex piece of software, and what it essentially does is, taking one representation of a program as an input and generating a representation of the same program.&lt;/p&gt;
&lt;p&gt;This input representation is usually the text file containing the source code that complies with the specifications of a specific high-level language. And the&lt;/p&gt;
&lt;p&gt;Output is usually a low-level language representation of the same program.&lt;/p&gt;
&lt;p&gt;Sounds not that complex right? Well, this is just a high-level overview. During this process of translation between different representations, the input source will have to face many algorithms, techniques employed by the compiler to optimize the low-level representation it generates. These algorithms may add more levels of complexity on top of the original code.&lt;/p&gt;
&lt;p&gt;And may even contain code that the developer is not intended of writing. These things make it harder for someone to read the compiler-generated code.&lt;/p&gt;
&lt;h2 id=&#34;compiler-architecture&#34;&gt;Compiler architecture.&lt;/h2&gt;
&lt;p&gt;Compiler architecture mainly consists of 3 things&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Front end
- Optimizer
- Back end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I this first article, let&amp;rsquo;s dive into the Front end.&lt;/p&gt;
&lt;h2 id=&#34;the-front-end&#34;&gt;The front end.&lt;/h2&gt;
&lt;p&gt;tbh, the front is the least important out of the above 3 in a reverse engineering perspective. anyway&amp;hellip;&lt;/p&gt;
&lt;p&gt;So what does this thing do? well, the front end is the place where the process of compilation begins.&lt;/p&gt;
&lt;h2 id=&#34;lexical-analysis&#34;&gt;Lexical analysis&lt;/h2&gt;
&lt;p&gt;Lexical analyzer is a part of the compiler front end and is responsible for tokenizing the given source file. What this means is that, when given a stream of characters, a lexical analyzer can turn that stream of characters into a set of distinct lexemes. These lexemes can&lt;/p&gt;
&lt;p&gt;be separated by some delimiter. A token can have many lexemes, which essentially means that a token is a category of lexemes if that makes sense.&lt;/p&gt;
&lt;p&gt;for example, following statement&lt;/p&gt;
&lt;p&gt;&lt;code&gt; if ( i == 0 )&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;can be broken down into&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;lexemes&lt;/th&gt;
&lt;th&gt;token&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;if&lt;/td&gt;
&lt;td&gt;condition&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(&lt;/td&gt;
&lt;td&gt;bracket_open&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;indetifier&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;==&lt;/td&gt;
&lt;td&gt;equal_sign&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;)&lt;/td&gt;
&lt;td&gt;bracket_end&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Tokenizing is very similar to how we break down complex sentences in natural languages. just like how a sentence is divided into different parts.&lt;/p&gt;
&lt;p&gt;But unlike humans, to achieve this task, lexical analyzers use pattern matching algorithms and regular expressions.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s also worth mentioning that lexical analysis or tokenizing can be done using unix utilities like FLEX and ANTLR.&lt;/p&gt;
&lt;h2 id=&#34;syntax-analysis&#34;&gt;Syntax analysis&lt;/h2&gt;
&lt;p&gt;Syntax analysis is the second phase of the compiler&amp;rsquo;s front end. Unlike lexical analysis, where pattern matching algorithms and regular expressions are used to identify tokens, Syntax analysis use a&lt;/p&gt;
&lt;p&gt;concept known as Context-Free Grammar (CFGs). Context-Free Grammar is kinda similar to regular grammar but it&amp;rsquo;s mainly used to describe the syntax of programming languages. basically, it&amp;rsquo;s a superset of regular grammar.&lt;/p&gt;
&lt;p&gt;When the lexical analyzer outputs the stream of tokens, these tokens are then fed into the syntax analyzer. Then the syntax analyzer analyzes and parses the stream of tokens against different rules and&lt;/p&gt;
&lt;p&gt;detect syntax errors in the code.&lt;/p&gt;
&lt;p&gt;for example, &lt;code&gt;if ( i == 0 &lt;/code&gt; is passed down, it is the syntax analyzers job to report it as an error. However, some syntax analyzers are capable of continuing the parsing process even if there are syntax errors. To achieve&lt;/p&gt;
&lt;p&gt;this, syntax analyzers use error recovery strategies.&lt;/p&gt;
&lt;p&gt;After parsing all the syntax, the syntax analyzer should generate a parse tree. A parse tree is a representation of the production rules.&lt;/p&gt;
&lt;p&gt;for example, applying left-derivation production rule on &lt;code&gt;x + b - c&lt;/code&gt;, resulting parse tree is&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;E -&amp;gt; E - E

E -&amp;gt; E + E - E

E -&amp;gt; id + E - E

E -&amp;gt; id + id - id



        E
    ---------
    |   |   |
    E   -   E
____|____
|   |   |
E   +   E
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Syntax analysis can be done using YACC(Yet Another Compiler Compiler), CUP, Bison, and ANTLR.&lt;/p&gt;
&lt;h3 id=&#34;abstract-synstax-trees-asts&#34;&gt;Abstract Synstax Trees (ASTs)&lt;/h3&gt;
&lt;p&gt;Just like a parse tree, an abstract syntax tree or AST is a graph representation of the source code. How an AST differs from a parse tree is, an AST is a simplified version of the parse tree. And in ASTs operators are internal nodes. ASTs are also considered to be the out of syntax analysis phase of a compiler.&lt;/p&gt;
&lt;p&gt;Remember CFGs?, in modern programming languages, there are lots of things that CFGs cant express. for example type definitions. Almost every modern language allows new types. However, CFGs cannot represent new types and&lt;/p&gt;
&lt;p&gt;their usage. ASTs can solve these problems.&lt;/p&gt;
&lt;p&gt;Another major usage of ASTs is that a full traversal of the AST data structure represents the correctness of the program. ASTs are heavily used in semantic analysis too.&lt;/p&gt;
&lt;h2 id=&#34;the-end&#34;&gt;THE END&lt;/h2&gt;
&lt;p&gt;So yeah that&amp;rsquo;s it for the compiler front end. I suggest readers go through &amp;ldquo;Concepts of programming languages&amp;rdquo; for more detailed explanations.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ll do the optimization article soon. until then&amp;hellip;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Hello, welcome to rxOred&#39;s corner of this inter-networked maze!</title>
      <link>https://rxOred.github.io/post/hello/</link>
      <pubDate>Tue, 28 Sep 2021 16:21:05 +0000</pubDate>
      
      <guid>https://rxOred.github.io/post/hello/</guid>
      <description>Tbh, I don&amp;rsquo;t really know what to write here. A few years ago, when I started out programming, I never thought of or wanted to start blogging. Hell, I never wanted to get into security back then. But things change!.
Here I am, editing the first blog post :)
Anyway, about this blog. Here I will be posting my projects, research, guides, and other useless information on programming, system security, and reverse engineering.</description>
      <content>&lt;p&gt;Tbh, I don&amp;rsquo;t really know what to write here. A few years ago, when I started out programming, I never thought of or wanted to start blogging. Hell, I never wanted to get into security back then. But things change!.&lt;/p&gt;
&lt;p&gt;Here I am, editing the first blog post :)&lt;/p&gt;
&lt;p&gt;Anyway, about this blog. Here I will be posting my projects, research, guides, and other useless information on programming, system security, and reverse engineering. I&amp;rsquo;m also looking forward to starting posting malware analysis reports and CTF writeups.&lt;/p&gt;
&lt;p&gt;So, I think that&amp;rsquo;s it :3&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
